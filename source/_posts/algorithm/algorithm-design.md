---
title: 单例模式
date: 2020-08-19
tags: 
	- 算法
	- algorithm
categories:
	- 算法
---

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

![算法.png](https://s1.ax1x.com/2020/08/19/d3p62R.png)

<!-- more -->


# Hash算法

hash算法又称散列函数是一种公开的数学函数，函数输入的信息叫做报文，匀后所得到的结果叫做散列码或者叫做消息摘要。

散列函数h = H(M)，具有如下特点:

- 不同内容的报文具有不同的散列值。
- 散列函数是单向的，不可逆。
- 对于任何一个报文，无法预知它的散列码。
- 散列码具有固定长度。

常见的散列函数有MD5、SHA和HMAC等。

MD5（Message Digest 5）是一种非常著名的散列算法，已成为国际标准。MD5散列算法对输入的任意长度的消息产生128位（16字节）长度的消息摘要，MD5算法包括以下4个步骤：

- 按位补充数据：补充后的数据长度模512后于448，也就是说数据补位后，其位数长度只差64位(bit)就是512的整数倍。即便是这个数据的位数对512求模的结果正好是448也必须进行补位。

- 补足长度：将数据长度表示为二进制，如果长度超过64位，则获取其低64位；如果长度不足64位，则在其高位补0。然后将得到的64位报文添加在经过填充的报文后，得到的结果数据长度正好是512的整数倍。也就是说长度正好是16个(32bit) 字的整数倍。

- 初始化MD缓存器：MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为 :

  A ： 01 23 45 67

  B： 89 ab cd ef

  C： fe dc ba 98

  D： 76 54 32 10

- 处理数据段：首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD(128位)。

信息摘要最终处理成以A, B, C, D 的形式输出。也就是开始于A的低位在前的顺序字节，结束于D的高位在前的顺序字节。

# 算法复杂度

算法复杂度分为时间复杂度和空间复杂度。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。（算法的复杂性体运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。）

## 时间复杂度

算法的时间复杂度是一个函数，它定性**描述该算法的运行时间**。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。

常见时间复杂度：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

## 空间复杂度

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。

# 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。对数据存储有如下要求：

- 必须采用顺序存储结构
- 必须按关键字大小有需排列

查找流程大致如下图所示：

![二分查找.png](https://bkimg.cdn.bcebos.com/pic/3ac79f3df8dcd1003d97f14e728b4710b9122f51?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5)

空间复杂度：O(1)

时间复杂度：O(log<sub>2</sub><sup>n</sup>)，最差情况查找的数据为最大或者最小，查找次数最多O(logn)

# 排序算法

## 算法分类

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![排序算法分类.png](https://s1.ax1x.com/2020/08/19/d3SN7D.png)

##  算法复杂度

![排序算法复杂度](https://s1.ax1x.com/2020/08/19/d3SgHS.png)

其中：

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

## 逗比排序

- 睡眠排序：这是一个思想比较简单，脑洞巨大的算法 -- 我们知道sleep方法可以让一个线程睡眠s毫秒，如果需要对一个有n个数的数列进行排序，我们何不为每个数创建一个线程，然后让每个线程都睡眠该数的时间，那么对于越小的数，其睡眠时间越短，越大的数，其睡眠时间越长，最后就使得所有元素完成“排序”了。
- 猴子排序（随机排序）：猴子排序引用了无限猴子定理：即一只猴子随机不停的敲击键盘，如果时间足够长，那么它总有可能会打出特定的文本，比如莎士比亚全集？，算法通过不停的随机排列数组，直到数组有序。

# 动态规划

动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

- 重叠子问题，保存计算结果存到表中，遇到重复子问题从表中获取，可以极大减少计算量

  - 最长公共子序列（LCS）：是一个在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。
  - Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法或佛洛依德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。

- 最优子结构，局部最优解--》全局最优解

  - 贪心算法

    贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。

  - 01背包

  - 最小生成树

  - 哈弗曼编码

# 数据结构

## 数组

![数组.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6c84433da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 链表

![链表.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6c0eddb88?imageslim)

**链表和数组对比**

链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。

![链表和数组对比.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6c83bdd33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 跳表

从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。

![跳表.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6bbe1231f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。

从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。

- ConcurrentSkipListMap
- ConcurrentSkipListSet
- redis的跳跃表(skiplist)

## 栈

![栈.gif](https://user-gold-cdn.xitu.io/2020/5/24/172472f6cccaf5f0?imageslim)

## 队列

![队列.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6f03e72b3?imageslim)

## 树

树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。

### 二叉树

![二叉树.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6e74c7c8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

二叉树每个结点最多有两个子树，二叉树根据结点的排列和数量还可进一度划分：

- **完全二叉树**：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。
- **满二叉树**：除了最后一层，其它层的结点都有两个子结点。
- **二叉排序树**：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。
- 平衡二叉树：

![平衡二叉树.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f6f5235ee6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。

### 红黑树

平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。

为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。

红黑树具有五个特性：

> 1. 每个结点要么是红的要么是黑的。
> 2. 根结点是黑的。
> 3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。
> 4. 如果一个结点是红的，那么它的两个儿子都是黑的。
> 5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f72c8875f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。Java8中HashMap使用数组+红黑树作为底层的数据结构。

**红黑树VS平衡二叉树**

![红黑树VS平衡二叉树.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f75866b55d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 图

图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。

![图.png](https://user-gold-cdn.xitu.io/2020/5/24/172472f75600f8a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 邻接矩阵

目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f763cecc6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f764d72686?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。

用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。

而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。

因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。

### 邻接表

在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f7826669a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B->A->E，其它顶点亦如此。

通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。

> 入度：有向图的某个顶点作为终点的次数和。
>
> 出度：有向图的某个顶点作为起点的次数和。

由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。

### 逆邻接表

逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f782bcfa08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。

### 十字链表

十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f782d0df9b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。

十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）

> **data**：用于存储该顶点中的数据；
>
> **firstin指针**：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；
>
> **firstout指针**：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；

边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：

> **tailvex**：用于存储作为弧尾的顶点的编号；
>
> **headvex**：用于存储作为弧头的顶点的编号；
>
> **headlink** **指针**：用于链接下一个存储作为弧头的顶点的节点；
>
> **taillink** **指针**：用于链接下一个存储作为弧尾的顶点的节点；

![img](https://user-gold-cdn.xitu.io/2020/5/24/172472f787dc80e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边`AE`（即边04）指向顶点E，顶点A的`firstout`指针需要指向边04的`tailvex`。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边`AB`（即边10）指向B，顶点A的`firstin`指针需要指向边10的弧头，即`headlink`指针。依次类推。

十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。